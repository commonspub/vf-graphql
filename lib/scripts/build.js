/**
 * Build script for packaging the GraphQL source files as nodejs modules
 *
 * @package: HoloREA
 * @since:   2019-05-22
 * @flow
 */

const fs = require('fs')
const path = require('path')
const globby = require('globby')

const {
  graphqlSync,
  getIntrospectionQuery,
  buildASTSchema,
  printSchema,
} = require('graphql')
const { mergeTypeDefs } = require('@graphql-tools/merge')
const { fromIntrospectionQuery } = require('graphql-2-json-schema')

// template for precompiled output JS files
const TEMPLATE = `
// Generated by scripts/build.js - edit the *.gql file instead!

module.exports = \`
$SCHEMA_DOCUMENT
\`
`

// templates for schemas manifest
const TYPEDEFS_TEMPLATE = `
// Generated by scripts/build.js - any edits to this file will be wiped upon building!

module.exports = {
  schemaModules: {
$SCHEMA_MODULES
  },
  bridgingSchemas: {
$BRIDGING_SCHEMAS
  },
}
`
const REQUIRE_BLOCK = (builtSchemaFilename) => `    '${builtSchemaFilename}': require('./build/${builtSchemaFilename}'),`

// BEGIN BUILD SCRIPT LOGIC
;(async() => {
  const typeDefs = []
  const schemaModules = []
  const bridgingSchemas = []

  for await (const filePath of globby.stream(path.resolve(__dirname, `../schemas/**/*.gql`))) {
    const doc = fs.readFileSync(filePath)
    const docString = doc.toString()
    const fileId = path.basename(filePath, '.gql')

    // bundle each schema file as a nodejs module that exports a string
    fs.writeFileSync(
      path.resolve(__dirname, `../build/${fileId}.js`),
      TEMPLATE.replace('$SCHEMA_DOCUMENT', docString.replace(/`/g, '\\`'))
    )

    // append to complete schema
    typeDefs.push(docString)

    // track module IDs
    if (path.dirname(filePath).match(/bridging$/)) {
      bridgingSchemas.push(fileId)
    } else {
      schemaModules.push(fileId)
    }
  }

  // compile full schema by merging all parts. This also has the side effect of validating the input files.
  const schema = buildASTSchema(mergeTypeDefs(typeDefs, { throwOnConflict: true }))

  // write an SDL version of the full merged schema
  fs.writeFileSync(
    path.resolve(__dirname, `../ALL_VF_SDL.js`),
    TEMPLATE.replace('$SCHEMA_DOCUMENT', printSchema(schema).replace(/`/g, '\\`'))
  )

  // generate & write JSON Schema version by running introspection query. Also performs runtime validation of the schema.
  const introspection = graphqlSync({ schema, source: getIntrospectionQuery() })

  if (!introspection) {
    throw new Error('Unknown error executing introspection query. Schema may be invalid- does `npm run test` pass?')
  } else if (introspection.error) {
    throw introspection.error
  } else if (introspection.errors) {
    introspection.errors.forEach(e => console.error('\x1b[1m\x1b[31mGraphQL schema error\x1b[0m ' + e.message))
    process.exit(1)
  }

  fs.writeFileSync(
    path.resolve(__dirname, `../json-schema.json`),
    JSON.stringify(fromIntrospectionQuery(introspection.data), undefined, 2)
  )

  // write schemas manifest
  fs.writeFileSync(
    path.resolve(__dirname, `../schema-manifest.js`),
    TYPEDEFS_TEMPLATE
      .replace('$SCHEMA_MODULES', schemaModules.map(REQUIRE_BLOCK).join('\n'))
      .replace('$BRIDGING_SCHEMAS', bridgingSchemas.map(REQUIRE_BLOCK).join('\n'))
  )

  // copy meta files from project root
  fs.copyFileSync(path.resolve(__dirname, '../../LICENSE'), path.resolve(__dirname, '../LICENSE'))
  fs.copyFileSync(path.resolve(__dirname, '../../README.md'), path.resolve(__dirname, '../README.md'))
  fs.copyFileSync(path.resolve(__dirname, '../../CHANGELOG.md'), path.resolve(__dirname, '../CHANGELOG.md'))
})()
